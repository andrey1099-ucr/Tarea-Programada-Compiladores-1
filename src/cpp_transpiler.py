from __future__ import annotations

from typing import List, Set

from src.ast_nodes import (
    Program,
    FunctionDef,
    Name,
    Constant,
    Assign,
    Return,
    Pass,
    Break,
    Continue,
    If,
    While,
    For,
    Call,
    BinaryOp,
    UnaryOp,
    ListLiteral,
    TupleLiteral,
    DictLiteral,
    KeyValue,
    Index,
    Attribute,
    Node,
)


class CppTranspiler:
    def __init__(self) -> None:
        self.lines: List[str] = []
        self.indent_level: int = 0

    # Generates C++ code from program node:
    def transpile(self, program: Program) -> str:
        self.lines = []
        self.indent_level = 0

        self._emit_preamble()
        self.emit_program(program)

        return "\n".join(self.lines)

    # Adds a line with a 4 space indent:
    def emit(self, line: str = "") -> None:
        indent = "    " * self.indent_level
        self.lines.append(indent + line)

    # Add or take indentation levels:
    def indent(self) -> None:
        self.indent_level += 1

    def dedent(self) -> None:
        if self.indent_level > 0:
            self.indent_level -= 1

    # Header statements and includes:
    def _emit_preamble(self) -> None:
        self.emit("// Generated by simple Fangless Python transpiler")
        self.emit('#include "../c++/runtime.hpp"')
        self.emit("")
        self.emit("// Compile with something like:")
        self.emit("//   g++ -std=c++17 -O3 output.cpp -o program")
        self.emit("")

    # Gets functions and global statements:
    def emit_program(self, program: Program) -> None:
        functions: List[FunctionDef] = []
        globals: List[Node] = []

        for node in program.body:
            if isinstance(node, FunctionDef):
                functions.append(node)
            else:
                globals.append(node)

        # Emits all function definitions first:
        for func in functions:
            self.emit_function(func)
            self.emit("")

        # Emits main method with all global statements:
        self.emit_main(globals)

    # Indicates which identifiers are modified by methods:
    def collect_mutated_names_in_expr(self, node: Node) -> Set[str]:
        mutated: Set[str] = set()

        if isinstance(node, Call):

            # Container methods: obj.method(...)
            if isinstance(node.func, Attribute) and isinstance(node.func.value, Name):
                method_name = node.func.attr.id
                obj_name = node.func.value.id

                # If append, add or remove, we assume object is modified:
                if method_name in ("append", "add", "remove"):
                    mutated.add(obj_name)

            # Recursive call for arguments:
            for arg in node.args:
                mutated |= self.collect_mutated_names_in_expr(arg)

        elif isinstance(node, BinaryOp):
            mutated |= self.collect_mutated_names_in_expr(node.left)
            mutated |= self.collect_mutated_names_in_expr(node.right)

        elif isinstance(node, UnaryOp):
            mutated |= self.collect_mutated_names_in_expr(node.operand)

        elif isinstance(node, ListLiteral):
            for e in node.elements:
                mutated |= self.collect_mutated_names_in_expr(e)

        elif isinstance(node, TupleLiteral):
            for e in node.elements:
                mutated |= self.collect_mutated_names_in_expr(e)

        elif isinstance(node, DictLiteral):
            for pair in node.pairs:
                mutated |= self.collect_mutated_names_in_expr(pair.key)
                mutated |= self.collect_mutated_names_in_expr(pair.value)

        elif isinstance(node, Index):
            mutated |= self.collect_mutated_names_in_expr(node.value)
            mutated |= self.collect_mutated_names_in_expr(node.index)

        # Name, Constant, etc. do not add anything here.
        return mutated

    # Checks sentences to identify variables:
    def collect_assigned_names_in_stmts(self, stmts: List[Node]) -> Set[str]:
        names: Set[str] = set()

        for stmt in stmts:
            # Simple or indexed assignments:
            if isinstance(stmt, Assign):
                # x = expr
                if isinstance(stmt.target, Name):
                    names.add(stmt.target.id)
                # a[i] = expr (a was modified)
                elif isinstance(stmt.target, Index) and isinstance(stmt.target.value, Name):
                    names.add(stmt.target.value.id)

                # Look for mutations to the right side:
                names |= self.collect_mutated_names_in_expr(stmt.value)

            # Return (may change containers)
            elif isinstance(stmt, Return) and stmt.value is not None:
                names |= self.collect_mutated_names_in_expr(stmt.value)

            # IF - ELIF - ELSE:
            elif isinstance(stmt, If):
                names |= self.collect_mutated_names_in_expr(stmt.condition)
                names |= self.collect_assigned_names_in_stmts(stmt.body)

                for elif_clause in stmt.elifs:
                    names |= self.collect_mutated_names_in_expr(elif_clause.condition)
                    names |= self.collect_assigned_names_in_stmts(elif_clause.body)

                if stmt.orelse:
                    names |= self.collect_assigned_names_in_stmts(stmt.orelse)

            # While loop
            elif isinstance(stmt, While):
                names |= self.collect_mutated_names_in_expr(stmt.condition)
                names |= self.collect_assigned_names_in_stmts(stmt.body)

            # For loop
            elif isinstance(stmt, For):
                # loop variable is being written over on each iteration:
                if isinstance(stmt.target, Name):
                    names.add(stmt.target.id)

                names |= self.collect_mutated_names_in_expr(stmt.iterable)
                names |= self.collect_assigned_names_in_stmts(stmt.body)

            # Expression statement: could be a container method call
            elif isinstance(stmt, Call):
                names |= self.collect_mutated_names_in_expr(stmt)

        return names

    # Functions:
    def emit_function(self, func: FunctionDef) -> None:
        # Get parameters' names:
        param_names = [p.name.id for p in func.params]

        # Get all names assigned or modified inside body:
        assigned_or_mutated = self.collect_assigned_names_in_stmts(func.body)

        # Build parameter declarations:
        # if a param is never assigned / mutated: generate a const PyValue&
        # if it is assigned / mutated: generate a PyValue by value

        param_decls: List[str] = []

        for p in func.params:
            name = p.name.id
            
            if name in assigned_or_mutated:
                param_decls.append(f"PyValue {name}")

            else:
                param_decls.append(f"const PyValue& {name}")

        # Joins with ',' for multiple parameters:
        params_code = ", ".join(param_decls)

        # Function header and brackets:
        self.emit(f"PyValue {func.name.id}({params_code}) {{")
        self.indent()

        # Variables (assigned or mutated) that are not parameters are considered local:
        local_vars = assigned_or_mutated.difference(param_names)

        # Declare all local variables at the beginning:
        for var in sorted(local_vars):
            self.emit(f"PyValue {var};")

        # Set of all declared names inside function:
        declared: Set[str] = set(param_names) | local_vars

        #  Emit function body:
        for stmt in func.body:
            self.emit_stmt(stmt, declared)

        # If control reaches here, return None (all functions must return PyValue)
        self.emit("return PyValue();")

        # Close function:
        self.dedent()
        self.emit("}")

    # Main function:
    def emit_main(self, stmts: List[Node]) -> None:
        self.emit("int main() {")
        self.indent()

        # Get all assigned variables:
        assigned = self.collect_assigned_names_in_stmts(stmts)

        # Set of all declared names inside function (main has no params):
        local_vars = assigned
        
        # Declare all local variables at the beginning:
        for var in sorted(local_vars):
            self.emit(f"PyValue {var};")

        declared: Set[str] = set(local_vars)

        # Emit function body:
        for stmt in stmts:
            self.emit_stmt(stmt, declared)

        # Close main:
        self.emit("return 0;")
        self.dedent()
        self.emit("}")

    # Statement emit:
    def emit_stmt(self, node: Node, declared: Set[str]) -> None:
        if isinstance(node, Assign):
            self.emit_assign(node, declared)
        elif isinstance(node, Return):
            self.emit_return(node)
        elif isinstance(node, If):
            self.emit_if(node, declared)
        elif isinstance(node, While):
            self.emit_while(node, declared)
        elif isinstance(node, For):
            self.emit_for(node, declared)
        elif isinstance(node, Call):
            self.emit_call_stmt(node, declared)
        elif isinstance(node, Pass):
            self.emit("; // pass")
        elif isinstance(node, Break):
            self.emit("break;")
        elif isinstance(node, Continue):
            self.emit("continue;")
        else:
            raise NotImplementedError(f"Unsupported statement: {type(node).__name__}")

    def emit_assign(self, stmt: Assign, declared: Set[str]) -> None:
        # Simple variable assignment (x = expr):
        if isinstance(stmt.target, Name):
            var_name = stmt.target.id
            expr_code = self.expression(stmt.value)

            if var_name in declared:
                self.emit(f"{var_name} = {expr_code};")
            else:
                # In case something was not collected, declare it here as a precaution:
                declared.add(var_name)
                self.emit(f"PyValue {var_name} = {expr_code};")
            return

        # Indexed element assignment: (list[i] = expr):
        if isinstance(stmt.target, Index):
            if not isinstance(stmt.target.value, Name):
                raise NotImplementedError(
                    "Only simple indexed assignment like a[i] = value is supported"
                )

            container_name = stmt.target.value.id
            index_code = self.expression(stmt.target.index)
            value_code = self.expression(stmt.value)

            # py_setitem(container, index, value);
            self.emit(f"py_setitem({container_name}, {index_code}, {value_code});")
            return

        # Anything else is not supported:
        raise NotImplementedError(
            f"Unsupported assignment target type: {type(stmt.target).__name__}"
        )

    # Returns empty PyValue or expression:
    def emit_return(self, stmt: Return) -> None:
        if stmt.value is None:
            self.emit("return PyValue();")
        else:
            expr_code = self.expression(stmt.value)
            self.emit(f"return {expr_code};")

    def emit_if(self, stmt: If, declared: Set[str]) -> None:
        # IF:
        cond_code = self.expression(stmt.condition)
        self.emit(f"if ({cond_code}.is_truthy()) {{")
        self.indent()
        for s in stmt.body:
            self.emit_stmt(s, declared)
        self.dedent()
        self.emit("}")

        # ELIFS:
        for elif_clause in stmt.elifs:
            cond_code = self.expression(elif_clause.condition)
            self.emit(f"else if ({cond_code}.is_truthy()) {{")
            self.indent()
            for s in elif_clause.body:
                self.emit_stmt(s, declared)
            self.dedent()
            self.emit("}")

        # ELSE:
        if stmt.orelse:
            self.emit("else {")
            self.indent()
            for s in stmt.orelse:
                self.emit_stmt(s, declared)
            self.dedent()
            self.emit("}")

    def emit_while(self, stmt: While, declared: Set[str]) -> None:
        cond_code = self.expression(stmt.condition)
        self.emit(f"while ({cond_code}.is_truthy()) {{")
        self.indent()
        for s in stmt.body:
            self.emit_stmt(s, declared)
        self.dedent()
        self.emit("}")

    def emit_for(self, stmt: For, declared: Set[str]) -> None: 
        iterable = stmt.iterable

        # for i in range(...):
        if (isinstance(iterable, Call) and isinstance(iterable.func, Name) and iterable.func.id == "range"
        ):
            self.emit_for_range(stmt, iterable, declared)
        # for x in iterable:
        else:
            self.emit_for_iterable(stmt, declared)

    def emit_for_range(self, stmt: For, range_call: Call, declared: Set[str]) -> None:
        target_name = stmt.target.id
        args = range_call.args
        n = len(args)
        # Turn range into start, stop, step:
        if n == 1:
            start_code = "PY_ZERO"
            stop_code = self.expression(args[0])
            step_code = "PY_ONE"
        elif n == 2:
            start_code = self.expression(args[0])
            stop_code = self.expression(args[1])
            step_code = "PY_ONE"
        elif n == 3:
            start_code = self.expression(args[0])
            stop_code = self.expression(args[1])
            step_code = self.expression(args[2])
        else:
            raise NotImplementedError(
                "range() with more than 3 arguments is not supported"
            )

        self.emit("{")
        self.indent()

        # Evaluate start / stop / step:
        self.emit(f"PyValue __range_start = {start_code};")
        self.emit(f"PyValue __range_stop = {stop_code};")
        self.emit(f"PyValue __range_step = {step_code};")

        # Check that loop variable is declared:
        if target_name not in declared:
            self.emit(f"PyValue {target_name};")
            declared.add(target_name)

        self.emit(
            "for (long long __i = __range_start.int_value; "
            "__i < __range_stop.int_value; "
            "__i += __range_step.int_value) {"
        )
        self.indent()

        # Assign new value to the loop variable on each loop:
        self.emit(f"{target_name} = PyValue(__i);")

        for s in stmt.body:
            self.emit_stmt(s, declared)

        # Create a local scope for the whole block:
        self.dedent()
        self.emit("}")

        self.dedent()
        self.emit("}")

    # Iterable for loop:
    def emit_for_iterable(self, stmt: For, declared: Set[str]) -> None:
        target_name = stmt.target.id
        iter_code = self.expression(stmt.iterable)

        self.emit("{")
        self.indent()

        # Evaluate iterable:
        self.emit(f"PyValue __iter = {iter_code};")

        # Emit a runtime check: only lists and tuples are supported:
        self.emit(
            "if (__iter.type != PyValue::LIST && __iter.type != PyValue::TUPLE) { "
            'throw std::runtime_error("TypeError: can only iterate over list or tuple in for-loop"); '
            "}"
        )
        # Check that loop variable is declared:
        if target_name not in declared:
            self.emit(f"PyValue {target_name};")
            declared.add(target_name)

        # Choose on what to iterate based on type:

        # List:
        self.emit("if (__iter.type == PyValue::LIST) {")
        self.indent()
        self.emit(
            "for (std::size_t __idx = 0; __idx < __iter.list_value.size(); ++__idx) {"
        )
        self.indent()
        self.emit(f"{target_name} = __iter.list_value[__idx];")
        for s in stmt.body:
            self.emit_stmt(s, declared)
        self.dedent()
        self.emit("}")
        self.dedent()
        # Tuple:
        self.emit("} else {")
        self.indent()
        self.emit(
            "for (std::size_t __idx = 0; __idx < __iter.tuple_value.size(); ++__idx) {"
        )
        self.indent()
        self.emit(f"{target_name} = __iter.tuple_value[__idx];")
        for s in stmt.body:
            self.emit_stmt(s, declared)
        self.dedent()
        self.emit("}")
        self.dedent()
        self.emit("}")

        self.dedent()
        self.emit("}")

    # Calls:
    def emit_call_stmt(self, call: Call, declared: Set[str]) -> None:
        # Print case:
        if isinstance(call.func, Name) and call.func.id == "print":
            if len(call.args) == 1:
                arg_code = self.expression(call.args[0])
                self.emit(f"py_print({arg_code});")
            else:
                args_code = ", ".join(self.expression(a) for a in call.args)
                self.emit(f"py_print_many(std::vector<PyValue>{{ {args_code} }});")
        # Any other call:
        else:
            expr_code = self.expression(call)
            self.emit(f"{expr_code};")

    # Expressions:
    def expression(self, node: Node) -> str:
        if isinstance(node, Name):
            return node.id
        if isinstance(node, Constant):
            return self.constant(node)
        if isinstance(node, BinaryOp):
            return self.binary_expression(node)
        if isinstance(node, UnaryOp):
            return self.unary_expression(node)
        if isinstance(node, Call):
            return self.expression_call(node)
        if isinstance(node, ListLiteral):
            return self.list_literal(node)
        if isinstance(node, TupleLiteral):
            return self.tuple_literal(node)
        if isinstance(node, DictLiteral):
            return self.dictionary_literal(node)
        if isinstance(node, Index):
            return self.index(node)

        raise NotImplementedError(f"Unsupported expression: {type(node).__name__}")

    def constant(self, node: Constant) -> str:
        val = node.value
        # Booleans:
        if isinstance(val, bool):
            return "PyValue(true)" if val else "PyValue(false)"
        # Integers:
        if isinstance(val, int):
            # Reuse small integer constants:
            if val == 0:
                return "PY_ZERO"
            if val == 1:
                return "PY_ONE"
            if val == 2:
                return "PY_TWO"
            return f"PyValue({val})"
        # Float:
        if isinstance(val, float):
            return f"PyValue({val})"
        # String:
        if isinstance(val, str):
            return f"PyValue({val})"
        # None:
        return "PyValue()"

    # Binary operations: Uses runtime functions to help with operation logic
    def binary_expression(self, node: BinaryOp) -> str:
        left = self.expression(node.left)
        right = self.expression(node.right)
        op = node.op

        # Arithmetic:
        if op == "ADD":
            return f"py_add({left}, {right})"
        if op == "MINUS":
            return f"py_sub({left}, {right})"
        if op == "TIMES":
            return f"py_mul({left}, {right})"
        if op == "DIVIDE":
            return f"py_div({left}, {right})"
        if op == "MODULE":
            return f"py_mod({left}, {right})"

        # Comparisons:
        if op == "EQUAL_EQUAL":
            return f"py_eq({left}, {right})"
        if op == "NOT_EQUAL":
            return f"py_ne({left}, {right})"
        if op == "LESS":
            return f"py_lt({left}, {right})"
        if op == "LESS_EQUAL":
            return f"py_le({left}, {right})"
        if op == "GREATER":
            return f"py_gt({left}, {right})"
        if op == "GREATER_EQUAL":
            return f"py_ge({left}, {right})"

        # Logical:
        if op == "AND":
            return f"py_and({left}, {right})"
        if op == "OR":
            return f"py_or({left}, {right})"

        raise NotImplementedError(f"Unsupported binary op: {op}")

    def unary_expression(self, node: UnaryOp) -> str:
        if node.op == "NOT":
            operand = self.expression(node.operand)
            return f"py_not({operand})"
        if node.op == "NEG": # Unary minus
            operand = self.expression(node.operand)
            # -x is implemented as 0 - x with py_sub:
            return f"py_sub(PY_ZERO, {operand})"

        raise NotImplementedError(f"Unsupported unary op: {node.op}")


    def expression_call(self, node: Call) -> str:
        # Function:
        if isinstance(node.func, Name):
            func_name = node.func.id

            # str(x) --> py_str(x):
            if func_name == "str":
                if len(node.args) != 1:
                    raise NotImplementedError(
                        "str() with != 1 argument is not supported"
                    )
                arg_code = self.expression(node.args[0])
                return f"py_str({arg_code})"

            # len(x) --> py_len(x):
            if func_name == "len":
                if len(node.args) != 1:
                    raise NotImplementedError(
                        "len() with != 1 argument is not supported"
                    )
                arg_code = self.expression(node.args[0])
                return f"py_len({arg_code})"

            # set(x) --> py_set_from_list(x):
            if func_name == "set":
                if len(node.args) != 1:
                    raise NotImplementedError(
                        "set() with != 1 argument is not supported"
                    )
                arg_code = self.expression(node.args[0])
                return f"py_set_from_list({arg_code})"

            # Regular function:
            args_code = ", ".join(self.expression(a) for a in node.args)
            return f"{func_name}({args_code})"

        # Container methods:
        if isinstance(node.func, Attribute):
            if not isinstance(node.func.value, Name):
                raise NotImplementedError(
                    "Container methods are only supported on simple variables"
                )

            obj_name = node.func.value.id
            method_name = node.func.attr.id
            args = [self.expression(a) for a in node.args]

            # list.append(x) --> py_list_append(x, y):
            if method_name == "append":
                if len(args) != 1:
                    raise NotImplementedError("append() expects exactly 1 argument")
                return f"py_list_append({obj_name}, {args[0]})"

            # list.sublist(start, end) --> py_list_sublist(x, y, z):
            if method_name == "sublist":
                if len(args) != 2:
                    raise NotImplementedError("sublist() expects exactly 2 arguments")
                return f"py_list_sublist({obj_name}, {args[0]}, {args[1]})"

            # Add (set or dict) --> py_dict_or_set_add():
            if method_name == "add":
                if len(args) == 1:
                    # Set:
                    return f"py_dict_or_set_add({obj_name}, {args[0]})"
                elif len(args) == 2:
                    # Dict:
                    return f"py_dict_or_set_add({obj_name}, {args[0]}, {args[1]})"
                else:
                    raise NotImplementedError("add() expects 1 or 2 arguments")

            # Get (set or dict) --> py_dict_or_set_get(x, y):
            if method_name == "get":
                if len(args) != 1:
                    raise NotImplementedError("get() expects exactly 1 argument")
                return f"py_dict_or_set_get({obj_name}, {args[0]})"

            # Remove --> py_container_remove:
            if method_name == "remove":
                if len(args) != 1:
                    raise NotImplementedError("remove() expects exactly 1 argument")
                return f"py_container_remove({obj_name}, {args[0]})"

            raise NotImplementedError(f"Unsupported container method: {method_name}")

        raise NotImplementedError(
            "Only simple function calls and basic container methods are supported for now"
        )

    def list_literal(self, node: ListLiteral) -> str:
        # Convert to PyValue list using vector:
        if not node.elements:
            return "py_list(std::vector<PyValue>{})"

        elems_code = ", ".join(self.expression(e) for e in node.elements)
        return f"py_list(std::vector<PyValue>{{ {elems_code} }})"

    def tuple_literal(self, node: TupleLiteral) -> str:
        # Convert to PyValue tuple using vector:
        if not node.elements:
            return "py_tuple(std::vector<PyValue>{})"

        elems_code = ", ".join(self.expression(e) for e in node.elements)
        return f"py_tuple(std::vector<PyValue>{{ {elems_code} }})"

    def dictionary_literal(self, node: DictLiteral) -> str:
        # Convert to PyValue dictionary using vector:
        if not node.pairs:
            return "py_dict(std::vector<std::pair<PyValue, PyValue>>{})"

        items_code_parts = []
        for pair in node.pairs:
            key_code = self.expression(pair.key)
            value_code = self.expression(pair.value)
            items_code_parts.append(f"std::make_pair({key_code}, {value_code})")

        items_code = ", ".join(items_code_parts)
        return "py_dict(std::vector<std::pair<PyValue, PyValue>>{ " + items_code + " })"

    def index(self, node: Index) -> str:
        # Convert value[index] --> py_getitem(value, index):
        container_code = self.expression(node.value)
        index_code = self.expression(node.index)
        return f"py_getitem({container_code}, {index_code})"
