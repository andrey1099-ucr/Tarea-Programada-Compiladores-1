# src/cpp_transpiler.py

from __future__ import annotations

from typing import List, Set

from src.ast_nodes import (
    Program,
    FunctionDef,
    Name,
    Constant,
    Assign,
    Return,
    If,
    While,
    Call,
    BinaryOp,
    UnaryOp,
    Node,
)


class CppTranspiler:

    def __init__(self) -> None:
        self.lines: List[str] = []
        self.indent_level: int = 0

    # ---------- public API ----------

    def transpile(self, program: Program) -> str:
        """Generate full C++ code from the root Program node."""
        self.lines = []
        self.indent_level = 0

        self._emit_preamble()
        self._emit_program(program)

        return "\n".join(self.lines)

    # ---------- low-level emit helpers ----------

    def _emit(self, line: str = "") -> None:
        indent = "    " * self.indent_level
        self.lines.append(indent + line)

    def _indent(self) -> None:
        self.indent_level += 1

    def _dedent(self) -> None:
        if self.indent_level > 0:
            self.indent_level -= 1

    # ---------- preamble and overall layout ----------

    def _emit_preamble(self) -> None:
        self._emit("// Generated by simple Fangless Python transpiler")
        self._emit('#include "../c++/runtime.hpp"')
        self._emit("")
        self._emit("// Compile with something like:")
        self._emit("//   g++ -std=c++17 output.cpp -o program")
        self._emit("")

    def _emit_program(self, program: Program) -> None:
        functions: List[FunctionDef] = []
        globals: List[Node] = []

        for node in program.body:
            if isinstance(node, FunctionDef):
                functions.append(node)
            else:
                globals.append(node)

        # Emit function definitions first
        for func in functions:
            self._emit_function(func)
            self._emit("")

        # Then emit main() with all global-level statements
        self._emit_main(globals)

    # ---------- assignment collection for Python-like scopes ----------

    def _collect_assigned_names_in_stmts(self, stmts: List[Node]) -> Set[str]:
        """
        Traverse a list of statements and return the set of variable names
        that appear as assignment targets (Name nodes).

        This includes assignments inside if / elif / else / while blocks.
        """
        names: Set[str] = set()

        for stmt in stmts:
            if isinstance(stmt, Assign):
                if isinstance(stmt.target, Name):
                    names.add(stmt.target.id)

            elif isinstance(stmt, If):
                # if body
                names |= self._collect_assigned_names_in_stmts(stmt.body)
                # elif clauses
                for elif_clause in stmt.elifs:
                    names |= self._collect_assigned_names_in_stmts(elif_clause.body)
                # else body
                if stmt.orelse:
                    names |= self._collect_assigned_names_in_stmts(stmt.orelse)

            elif isinstance(stmt, While):
                names |= self._collect_assigned_names_in_stmts(stmt.body)

        return names

    # ---------- functions and main ----------

    def _emit_function(self, func: FunctionDef) -> None:
        # All parameters are represented as PyValue
        param_names = [p.name.id for p in func.params]
        params_code = ", ".join(f"PyValue {name}" for name in param_names)

        self._emit(f"PyValue {func.name.id}({params_code}) {{")
        self._indent()

        # 1) Collect all assigned variable names inside the function body
        assigned = self._collect_assigned_names_in_stmts(func.body)

        # 2) Local variables are assigned names minus parameters
        local_vars = assigned.difference(param_names)

        # 3) Declare all local variables at the beginning (Python-like function scope)
        for var in sorted(local_vars):
            self._emit(f"PyValue {var};")

        # 4) Set of all declared names inside this function (params + locals)
        declared: Set[str] = set(param_names) | local_vars

        # 5) Emit the function body
        for stmt in func.body:
            self._emit_stmt(stmt, declared)

        # If control reaches here, return None
        self._emit("return PyValue();")

        self._dedent()
        self._emit("}")

    def _emit_main(self, stmts: List[Node]) -> None:
        self._emit("int main() {")
        self._indent()

        # Same logic as function scope: collect all assigned variables
        assigned = self._collect_assigned_names_in_stmts(stmts)
        local_vars = assigned  # main has no parameters

        for var in sorted(local_vars):
            self._emit(f"PyValue {var};")

        declared: Set[str] = set(local_vars)

        for stmt in stmts:
            self._emit_stmt(stmt, declared)

        self._emit("return 0;")
        self._dedent()
        self._emit("}")

    # ---------- statements ----------

    def _emit_stmt(self, node: Node, declared: Set[str]) -> None:
        if isinstance(node, Assign):
            self._emit_assign(node, declared)
        elif isinstance(node, Return):
            self._emit_return(node)
        elif isinstance(node, If):
            self._emit_if(node, declared)
        elif isinstance(node, While):
            self._emit_while(node, declared)
        elif isinstance(node, Call):
            self._emit_call_stmt(node, declared)
        else:
            raise NotImplementedError(f"Unsupported statement: {type(node).__name__}")

    def _emit_assign(self, stmt: Assign, declared: Set[str]) -> None:
        # Only support "name = expr" for now
        if not isinstance(stmt.target, Name):
            raise NotImplementedError(
                "Only simple variable assignment is supported for now"
            )

        var_name = stmt.target.id
        expr_code = self._expr(stmt.value)

        if var_name in declared:
            self._emit(f"{var_name} = {expr_code};")
        else:
            # Fallback in case something was not collected; declare it here
            declared.add(var_name)
            self._emit(f"PyValue {var_name} = {expr_code};")

    def _emit_return(self, stmt: Return) -> None:
        if stmt.value is None:
            self._emit("return PyValue();")
        else:
            expr_code = self._expr(stmt.value)
            self._emit(f"return {expr_code};")

    def _emit_if(self, stmt: If, declared: Set[str]) -> None:
        # if part
        cond_code = self._expr(stmt.condition)
        self._emit(f"if ({cond_code}.is_truthy()) {{")
        self._indent()
        for s in stmt.body:
            self._emit_stmt(s, declared)
        self._dedent()
        self._emit("}")

        # elif parts
        for elif_clause in stmt.elifs:
            cond_code = self._expr(elif_clause.condition)
            self._emit(f"else if ({cond_code}.is_truthy()) {{")
            self._indent()
            for s in elif_clause.body:
                self._emit_stmt(s, declared)
            self._dedent()
            self._emit("}")

        # else part
        if stmt.orelse:
            self._emit("else {")
            self._indent()
            for s in stmt.orelse:
                self._emit_stmt(s, declared)
            self._dedent()
            self._emit("}")

    def _emit_while(self, stmt: While, declared: Set[str]) -> None:
        cond_code = self._expr(stmt.condition)
        self._emit(f"while ({cond_code}.is_truthy()) {{")
        self._indent()
        for s in stmt.body:
            self._emit_stmt(s, declared)
        self._dedent()
        self._emit("}")

    def _emit_call_stmt(self, call: Call, declared: Set[str]) -> None:
        # Special-case builtin print(...)
        if isinstance(call.func, Name) and call.func.id == "print":
            if len(call.args) == 1:
                arg_code = self._expr(call.args[0])
                self._emit(f"py_print({arg_code});")
            else:
                args_code = ", ".join(self._expr(a) for a in call.args)
                self._emit(f"py_print_many(std::vector<PyValue>{{ {args_code} }});")
        else:
            expr_code = self._expr(call)
            self._emit(f"{expr_code};")

    # ---------- expressions ----------

    def _expr(self, node: Node) -> str:
        if isinstance(node, Name):
            return node.id
        if isinstance(node, Constant):
            return self._expr_constant(node)
        if isinstance(node, BinaryOp):
            return self._expr_binary(node)
        if isinstance(node, UnaryOp):
            return self._expr_unary(node)
        if isinstance(node, Call):
            return self._expr_call(node)

        raise NotImplementedError(f"Unsupported expression: {type(node).__name__}")

    def _expr_constant(self, node: Constant) -> str:
        val = node.value

        # In Python, bool is a subclass of int, so check it first
        if isinstance(val, bool):
            return "PyValue(true)" if val else "PyValue(false)"
        if isinstance(val, int):
            return f"PyValue({val})"
        if isinstance(val, float):
            return f"PyValue({val})"
        if isinstance(val, str):
            # In our AST, string literals usually already include quotes
            return f"PyValue({val})"

        # Fallback: None / unsupported
        return "PyValue()"

    def _expr_binary(self, node: BinaryOp) -> str:
        left = self._expr(node.left)
        right = self._expr(node.right)
        op = node.op

        # Arithmetic
        if op == "ADD":
            return f"py_add({left}, {right})"
        if op == "MINUS":
            return f"py_sub({left}, {right})"
        if op == "TIMES":
            return f"py_mul({left}, {right})"
        if op == "DIVIDE":
            return f"py_div({left}, {right})"
        if op == "MODULE":
            return f"py_mod({left}, {right})"

        # Comparisons
        if op == "EQUAL_EQUAL":
            return f"py_eq({left}, {right})"
        if op == "NOT_EQUAL":
            return f"py_ne({left}, {right})"
        if op == "LESS":
            return f"py_lt({left}, {right})"
        if op == "LESS_EQUAL":
            return f"py_le({left}, {right})"
        if op == "GREATER":
            return f"py_gt({left}, {right})"
        if op == "GREATER_EQUAL":
            return f"py_ge({left}, {right})"

        # Logical
        if op == "AND":
            return f"py_and({left}, {right})"
        if op == "OR":
            return f"py_or({left}, {right})"

        raise NotImplementedError(f"Unsupported binary op: {op}")

    def _expr_unary(self, node: UnaryOp) -> str:
        if node.op == "NOT":
            operand = self._expr(node.operand)
            return f"py_not({operand})"
        raise NotImplementedError(f"Unsupported unary op: {node.op}")

    def _expr_call(self, node: Call) -> str:
        # Only support calls to simple names: foo(...)
        if isinstance(node.func, Name):
            func_name = node.func.id

            # Builtin: str(x) -> py_str(x)
            if func_name == "str":
                if len(node.args) != 1:
                    raise NotImplementedError(
                        "str() with != 1 argument is not supported"
                    )
                arg_code = self._expr(node.args[0])
                return f"py_str({arg_code})"

            # Builtin: len(x) -> py_len(x)
            if func_name == "len":
                if len(node.args) != 1:
                    raise NotImplementedError(
                        "len() with != 1 argument is not supported"
                    )
                arg_code = self._expr(node.args[0])
                return f"py_len({arg_code})"

            # Regular function call: foo(a, b, ...)
            args_code = ", ".join(self._expr(a) for a in node.args)
            return f"{func_name}({args_code})"

        raise NotImplementedError("Only simple function calls are supported for now")
