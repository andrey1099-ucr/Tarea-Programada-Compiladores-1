# src/cpp_transpiler.py

from __future__ import annotations

from typing import List, Set

from src.ast_nodes import (
    Program,
    FunctionDef,
    Name,
    Constant,
    Assign,
    Return,
    Pass,
    Break,
    Continue,
    If,
    While,
    For,
    Call,
    BinaryOp,
    UnaryOp,
    ListLiteral,
    TupleLiteral,
    DictLiteral,
    KeyValue,
    Index,
    Attribute,
    Node,
)


class CppTranspiler:
    def __init__(self) -> None:
        self.lines: List[str] = []
        self.indent_level: int = 0

    # ---------- public API ----------

    def transpile(self, program: Program) -> str:
        """Generate full C++ code from the root Program node."""
        self.lines = []
        self.indent_level = 0

        self._emit_preamble()
        self._emit_program(program)

        return "\n".join(self.lines)

    # ---------- low-level emit helpers ----------

    def _emit(self, line: str = "") -> None:
        indent = "    " * self.indent_level
        self.lines.append(indent + line)

    def _indent(self) -> None:
        self.indent_level += 1

    def _dedent(self) -> None:
        if self.indent_level > 0:
            self.indent_level -= 1

    # ---------- preamble and overall layout ----------

    def _emit_preamble(self) -> None:
        self._emit("// Generated by simple Fangless Python transpiler")
        self._emit('#include "../../c++/runtime.hpp"')
        self._emit("")
        self._emit("// Compile with something like:")
        self._emit("//   g++ -std=c++17 -O3 output.cpp -o program")
        self._emit("")

    def _emit_program(self, program: Program) -> None:
        functions: List[FunctionDef] = []
        globals: List[Node] = []

        for node in program.body:
            if isinstance(node, FunctionDef):
                functions.append(node)
            else:
                globals.append(node)

        # Emit function definitions first
        for func in functions:
            self._emit_function(func)
            self._emit("")

        # Then emit main() with all global-level statements
        self._emit_main(globals)

    # ---------- analysis helpers for assignments / mutations ----------

    def _collect_mutated_names_in_expr(self, node: Node) -> Set[str]:
        mutated: Set[str] = set()

        if isinstance(node, Call):
            # Container methods: obj.method(...)
            if isinstance(node.func, Attribute) and isinstance(node.func.value, Name):
                method_name = node.func.attr.id
                obj_name = node.func.value.id

                if method_name in ("append", "add", "remove"):
                    mutated.add(obj_name)

            # Recurse into arguments
            for arg in node.args:
                mutated |= self._collect_mutated_names_in_expr(arg)

        elif isinstance(node, BinaryOp):
            mutated |= self._collect_mutated_names_in_expr(node.left)
            mutated |= self._collect_mutated_names_in_expr(node.right)

        elif isinstance(node, UnaryOp):
            mutated |= self._collect_mutated_names_in_expr(node.operand)

        elif isinstance(node, ListLiteral):
            for e in node.elements:
                mutated |= self._collect_mutated_names_in_expr(e)

        elif isinstance(node, TupleLiteral):
            for e in node.elements:
                mutated |= self._collect_mutated_names_in_expr(e)

        elif isinstance(node, DictLiteral):
            for pair in node.pairs:
                mutated |= self._collect_mutated_names_in_expr(pair.key)
                mutated |= self._collect_mutated_names_in_expr(pair.value)

        elif isinstance(node, Index):
            mutated |= self._collect_mutated_names_in_expr(node.value)
            mutated |= self._collect_mutated_names_in_expr(node.index)

        # Name, Constant, etc. do not add anything here.
        return mutated

    def _collect_assigned_names_in_stmts(self, stmts: List[Node]) -> Set[str]:
        names: Set[str] = set()

        for stmt in stmts:
            # Simple / indexed assignments
            if isinstance(stmt, Assign):
                # x = expr
                if isinstance(stmt.target, Name):
                    names.add(stmt.target.id)
                # a[i] = expr  -> treat 'a' as mutated
                elif isinstance(stmt.target, Index) and isinstance(
                    stmt.target.value, Name
                ):
                    names.add(stmt.target.value.id)

                # Look for mutations in RHS expression as well
                names |= self._collect_mutated_names_in_expr(stmt.value)

            # Return: may contain calls that mutate containers
            elif isinstance(stmt, Return) and stmt.value is not None:
                names |= self._collect_mutated_names_in_expr(stmt.value)

            # if / elif / else
            elif isinstance(stmt, If):
                names |= self._collect_mutated_names_in_expr(stmt.condition)
                names |= self._collect_assigned_names_in_stmts(stmt.body)

                for elif_clause in stmt.elifs:
                    names |= self._collect_mutated_names_in_expr(elif_clause.condition)
                    names |= self._collect_assigned_names_in_stmts(elif_clause.body)

                if stmt.orelse:
                    names |= self._collect_assigned_names_in_stmts(stmt.orelse)

            # while
            elif isinstance(stmt, While):
                names |= self._collect_mutated_names_in_expr(stmt.condition)
                names |= self._collect_assigned_names_in_stmts(stmt.body)

            # for
            elif isinstance(stmt, For):
                # loop variable is written each iteration
                if isinstance(stmt.target, Name):
                    names.add(stmt.target.id)

                names |= self._collect_mutated_names_in_expr(stmt.iterable)
                names |= self._collect_assigned_names_in_stmts(stmt.body)

            # Expression statement: could be a container method call
            elif isinstance(stmt, Call):
                names |= self._collect_mutated_names_in_expr(stmt)

            # Pass / Break / Continue: nothing to do

        return names

    # ---------- functions and main ----------

    def _emit_function(self, func: FunctionDef) -> None:
        # Parameter names
        param_names = [p.name.id for p in func.params]

        # 1) Collect all names assigned or mutated inside the function body
        assigned_or_mutated = self._collect_assigned_names_in_stmts(func.body)

        # 2) Build parameter declarations:
        #    - if a param is never assigned/mutated -> const PyValue&
        #    - otherwise -> PyValue (by value)
        param_decls: List[str] = []
        for p in func.params:
            name = p.name.id
            if name in assigned_or_mutated:
                param_decls.append(f"PyValue {name}")
            else:
                param_decls.append(f"const PyValue& {name}")

        params_code = ", ".join(param_decls)

        # Function header
        self._emit(f"PyValue {func.name.id}({params_code}) {{")
        self._indent()

        # 3) Local variables are assigned/mutated names minus parameters
        local_vars = assigned_or_mutated.difference(param_names)

        # 4) Declare all local variables at the beginning (Python-like function scope)
        for var in sorted(local_vars):
            self._emit(f"PyValue {var};")

        # 5) Set of all declared names inside this function (params + locals)
        declared: Set[str] = set(param_names) | local_vars

        # 6) Emit the function body
        for stmt in func.body:
            self._emit_stmt(stmt, declared)

        # If control reaches here, return None
        self._emit("return PyValue();")

        self._dedent()
        self._emit("}")

    def _emit_main(self, stmts: List[Node]) -> None:
        self._emit("int main() {")
        self._indent()

        # Same logic as function scope: collect all assigned variables
        assigned = self._collect_assigned_names_in_stmts(stmts)
        local_vars = assigned  # main has no parameters

        for var in sorted(local_vars):
            self._emit(f"PyValue {var};")

        declared: Set[str] = set(local_vars)

        for stmt in stmts:
            self._emit_stmt(stmt, declared)

        self._emit("return 0;")
        self._dedent()
        self._emit("}")

    # ---------- statements ----------

    def _emit_stmt(self, node: Node, declared: Set[str]) -> None:
        if isinstance(node, Assign):
            self._emit_assign(node, declared)
        elif isinstance(node, Return):
            self._emit_return(node)
        elif isinstance(node, If):
            self._emit_if(node, declared)
        elif isinstance(node, While):
            self._emit_while(node, declared)
        elif isinstance(node, For):
            self._emit_for(node, declared)
        elif isinstance(node, Call):
            self._emit_call_stmt(node, declared)
        elif isinstance(node, Pass):
            self._emit("; // pass")
        elif isinstance(node, Break):
            self._emit("break;")
        elif isinstance(node, Continue):
            self._emit("continue;")
        else:
            raise NotImplementedError(f"Unsupported statement: {type(node).__name__}")

    def _emit_assign(self, stmt: Assign, declared: Set[str]) -> None:
        # Case 1: simple variable assignment: x = expr
        if isinstance(stmt.target, Name):
            var_name = stmt.target.id
            expr_code = self._expr(stmt.value)

            if var_name in declared:
                self._emit(f"{var_name} = {expr_code};")
            else:
                # Fallback in case something was not collected; declare it here
                declared.add(var_name)
                self._emit(f"PyValue {var_name} = {expr_code};")
            return

        # Case 2: indexed assignment: a[i] = expr
        if isinstance(stmt.target, Index):
            # For simplicity, only allow something like "array[j] = value"
            if not isinstance(stmt.target.value, Name):
                raise NotImplementedError(
                    "Only simple indexed assignment like a[i] = value is supported"
                )

            container_name = stmt.target.value.id
            index_code = self._expr(stmt.target.index)
            value_code = self._expr(stmt.value)

            # py_setitem(container, index, value);
            self._emit(f"py_setitem({container_name}, {index_code}, {value_code});")
            return

        # Anything else is still unsupported
        raise NotImplementedError(
            f"Unsupported assignment target type: {type(stmt.target).__name__}"
        )

    def _emit_return(self, stmt: Return) -> None:
        if stmt.value is None:
            self._emit("return PyValue();")
        else:
            expr_code = self._expr(stmt.value)
            self._emit(f"return {expr_code};")

    def _emit_if(self, stmt: If, declared: Set[str]) -> None:
        # if part
        cond_code = self._expr(stmt.condition)
        self._emit(f"if ({cond_code}.is_truthy()) {{")
        self._indent()
        for s in stmt.body:
            self._emit_stmt(s, declared)
        self._dedent()
        self._emit("}")

        # elif parts
        for elif_clause in stmt.elifs:
            cond_code = self._expr(elif_clause.condition)
            self._emit(f"else if ({cond_code}.is_truthy()) {{")
            self._indent()
            for s in elif_clause.body:
                self._emit_stmt(s, declared)
            self._dedent()
            self._emit("}")

        # else part
        if stmt.orelse:
            self._emit("else {")
            self._indent()
            for s in stmt.orelse:
                self._emit_stmt(s, declared)
            self._dedent()
            self._emit("}")

    def _emit_while(self, stmt: While, declared: Set[str]) -> None:
        cond_code = self._expr(stmt.condition)
        self._emit(f"while ({cond_code}.is_truthy()) {{")
        self._indent()
        for s in stmt.body:
            self._emit_stmt(s, declared)
        self._dedent()
        self._emit("}")

    def _emit_for(self, stmt: For, declared: Set[str]) -> None:
        # Support two cases:
        #   for i in range(...):
        #   for x in some list or tuple:
        iterable = stmt.iterable

        if (
            isinstance(iterable, Call)
            and isinstance(iterable.func, Name)
            and iterable.func.id == "range"
        ):
            self._emit_for_range(stmt, iterable, declared)
        else:
            self._emit_for_iterable(stmt, declared)

    def _emit_for_range(self, stmt: For, range_call: Call, declared: Set[str]) -> None:
        target_name = stmt.target.id
        args = range_call.args
        n = len(args)

        # Translate Python range into start, stop, step.
        if n == 1:
            start_code = "PY_ZERO"
            stop_code = self._expr(args[0])
            step_code = "PY_ONE"
        elif n == 2:
            start_code = self._expr(args[0])
            stop_code = self._expr(args[1])
            step_code = "PY_ONE"
        elif n == 3:
            start_code = self._expr(args[0])
            stop_code = self._expr(args[1])
            step_code = self._expr(args[2])
        else:
            raise NotImplementedError(
                "range() with more than 3 arguments is not supported"
            )

        self._emit("{")
        self._indent()

        # Evaluate start/stop/step once.
        self._emit(f"PyValue __range_start = {start_code};")
        self._emit(f"PyValue __range_stop = {stop_code};")
        self._emit(f"PyValue __range_step = {step_code};")

        # Make sure the loop variable is declared.
        if target_name not in declared:
            self._emit(f"PyValue {target_name};")
            declared.add(target_name)

        self._emit(
            "for (long long __i = __range_start.int_value; "
            "__i < __range_stop.int_value; "
            "__i += __range_step.int_value) {"
        )
        self._indent()

        # Assign value to the loop variable each iteration.
        self._emit(f"{target_name} = PyValue(__i);")

        for s in stmt.body:
            self._emit_stmt(s, declared)

        self._dedent()
        self._emit("}")

        self._dedent()
        self._emit("}")

    def _emit_for_iterable(self, stmt: For, declared: Set[str]) -> None:
        target_name = stmt.target.id
        iter_code = self._expr(stmt.iterable)

        self._emit("{")
        self._indent()

        # Evaluate iterable expression once.
        self._emit(f"PyValue __iter = {iter_code};")

        # Simple runtime check: only lists and tuples are supported here.
        self._emit(
            "if (__iter.type != PyValue::LIST && __iter.type != PyValue::TUPLE) { "
            'throw std::runtime_error("TypeError: can only iterate over list or tuple in for-loop"); '
            "}"
        )

        if target_name not in declared:
            self._emit(f"PyValue {target_name};")
            declared.add(target_name)

        # Choose underlying container depending on type.
        self._emit("if (__iter.type == PyValue::LIST) {")
        self._indent()
        self._emit(
            "for (std::size_t __idx = 0; __idx < __iter.list_value.size(); ++__idx) {"
        )
        self._indent()
        self._emit(f"{target_name} = __iter.list_value[__idx];")
        for s in stmt.body:
            self._emit_stmt(s, declared)
        self._dedent()
        self._emit("}")
        self._dedent()
        self._emit("} else {")
        self._indent()
        self._emit(
            "for (std::size_t __idx = 0; __idx < __iter.tuple_value.size(); ++__idx) {"
        )
        self._indent()
        self._emit(f"{target_name} = __iter.tuple_value[__idx];")
        for s in stmt.body:
            self._emit_stmt(s, declared)
        self._dedent()
        self._emit("}")
        self._dedent()
        self._emit("}")

        self._dedent()
        self._emit("}")

    def _emit_call_stmt(self, call: Call, declared: Set[str]) -> None:
        # Special-case builtin print(...)
        if isinstance(call.func, Name) and call.func.id == "print":
            if len(call.args) == 1:
                arg_code = self._expr(call.args[0])
                self._emit(f"py_print({arg_code});")
            else:
                args_code = ", ".join(self._expr(a) for a in call.args)
                self._emit(f"py_print_many(std::vector<PyValue>{{ {args_code} }});")
        else:
            expr_code = self._expr(call)
            self._emit(f"{expr_code};")

    # ---------- expressions ----------

    def _expr(self, node: Node) -> str:
        if isinstance(node, Name):
            return node.id
        if isinstance(node, Constant):
            return self._expr_constant(node)
        if isinstance(node, BinaryOp):
            return self._expr_binary(node)
        if isinstance(node, UnaryOp):
            return self._expr_unary(node)
        if isinstance(node, Call):
            return self._expr_call(node)
        if isinstance(node, ListLiteral):
            return self._expr_list_literal(node)
        if isinstance(node, TupleLiteral):
            return self._expr_tuple_literal(node)
        if isinstance(node, DictLiteral):
            return self._expr_dict_literal(node)
        if isinstance(node, Index):
            return self._expr_index(node)

        raise NotImplementedError(f"Unsupported expression: {type(node).__name__}")

    def _expr_constant(self, node: Constant) -> str:
        val = node.value

        # In Python, bool is a subclass of int, so check it first
        if isinstance(val, bool):
            return "PyValue(true)" if val else "PyValue(false)"
        if isinstance(val, int):
            # Reuse small integer constants
            if val == 0:
                return "PY_ZERO"
            if val == 1:
                return "PY_ONE"
            if val == 2:
                return "PY_TWO"
            return f"PyValue({val})"
        if isinstance(val, float):
            return f"PyValue({val})"
        if isinstance(val, str):
            # In our AST, string literals usually already include quotes
            return f"PyValue({val})"

        # Fallback: None / unsupported
        return "PyValue()"

    def _expr_binary(self, node: BinaryOp) -> str:
        left = self._expr(node.left)
        right = self._expr(node.right)
        op = node.op

        # Arithmetic
        if op == "ADD":
            return f"py_add({left}, {right})"
        if op == "MINUS":
            return f"py_sub({left}, {right})"
        if op == "TIMES":
            return f"py_mul({left}, {right})"
        if op == "DIVIDE":
            return f"py_div({left}, {right})"
        if op == "MODULE":
            return f"py_mod({left}, {right})"

        # Comparisons
        if op == "EQUAL_EQUAL":
            return f"py_eq({left}, {right})"
        if op == "NOT_EQUAL":
            return f"py_ne({left}, {right})"
        if op == "LESS":
            return f"py_lt({left}, {right})"
        if op == "LESS_EQUAL":
            return f"py_le({left}, {right})"
        if op == "GREATER":
            return f"py_gt({left}, {right})"
        if op == "GREATER_EQUAL":
            return f"py_ge({left}, {right})"

        # Logical
        if op == "AND":
            return f"py_and({left}, {right})"
        if op == "OR":
            return f"py_or({left}, {right})"

        raise NotImplementedError(f"Unsupported binary op: {op}")

    def _expr_unary(self, node: UnaryOp) -> str:
        if node.op == "NOT":
            operand = self._expr(node.operand)
            return f"py_not({operand})"
        raise NotImplementedError(f"Unsupported unary op: {node.op}")

    def _expr_call(self, node: Call) -> str:
        # Builtin or user-defined function calls: foo(...)
        if isinstance(node.func, Name):
            func_name = node.func.id

            # Builtin: str(x) -> py_str(x)
            if func_name == "str":
                if len(node.args) != 1:
                    raise NotImplementedError(
                        "str() with != 1 argument is not supported"
                    )
                arg_code = self._expr(node.args[0])
                return f"py_str({arg_code})"

            # Builtin: len(x) -> py_len(x)
            if func_name == "len":
                if len(node.args) != 1:
                    raise NotImplementedError(
                        "len() with != 1 argument is not supported"
                    )
                arg_code = self._expr(node.args[0])
                return f"py_len({arg_code})"

            # Builtin: set(x) -> py_set_from_list(x)
            if func_name == "set":
                if len(node.args) != 1:
                    raise NotImplementedError(
                        "set() with != 1 argument is not supported"
                    )
                arg_code = self._expr(node.args[0])
                return f"py_set_from_list({arg_code})"

            # Regular function call: foo(a, b, ...)
            args_code = ", ".join(self._expr(a) for a in node.args)
            return f"{func_name}({args_code})"

        # Container methods: obj.method(...)
        if isinstance(node.func, Attribute):
            # For simplicity, only support methods on simple variables like "a.append(x)"
            if not isinstance(node.func.value, Name):
                raise NotImplementedError(
                    "Container methods are only supported on simple variables"
                )

            obj_name = node.func.value.id
            method_name = node.func.attr.id
            args = [self._expr(a) for a in node.args]

            # list.append(x)
            if method_name == "append":
                if len(args) != 1:
                    raise NotImplementedError("append() expects exactly 1 argument")
                return f"py_list_append({obj_name}, {args[0]})"

            # list.sublist(start, end)
            if method_name == "sublist":
                if len(args) != 2:
                    raise NotImplementedError("sublist() expects exactly 2 arguments")
                return f"py_list_sublist({obj_name}, {args[0]}, {args[1]})"

            # dict.add(key, value) or set.add(value)
            if method_name == "add":
                if len(args) == 1:
                    # set.add(value)
                    return f"py_dict_or_set_add({obj_name}, {args[0]})"
                elif len(args) == 2:
                    # dict.add(key, value)
                    return f"py_dict_or_set_add({obj_name}, {args[0]}, {args[1]})"
                else:
                    raise NotImplementedError("add() expects 1 or 2 arguments")

            # dict.get(key) or set.get(value)
            if method_name == "get":
                if len(args) != 1:
                    raise NotImplementedError("get() expects exactly 1 argument")
                return f"py_dict_or_set_get({obj_name}, {args[0]})"

            # list.remove(i), dict.remove(k), set.remove(v)
            if method_name == "remove":
                if len(args) != 1:
                    raise NotImplementedError("remove() expects exactly 1 argument")
                return f"py_container_remove({obj_name}, {args[0]})"

            raise NotImplementedError(f"Unsupported container method: {method_name}")

        raise NotImplementedError(
            "Only simple function calls and basic container methods are supported for now"
        )

    def _expr_list_literal(self, node: ListLiteral) -> str:
        # py_list(std::vector<PyValue>{ elem1, elem2, ... })
        if not node.elements:
            return "py_list(std::vector<PyValue>{})"

        elems_code = ", ".join(self._expr(e) for e in node.elements)
        return f"py_list(std::vector<PyValue>{{ {elems_code} }})"

    def _expr_tuple_literal(self, node: TupleLiteral) -> str:
        # py_tuple(std::vector<PyValue>{ elem1, elem2, ... })
        if not node.elements:
            return "py_tuple(std::vector<PyValue>{})"

        elems_code = ", ".join(self._expr(e) for e in node.elements)
        return f"py_tuple(std::vector<PyValue>{{ {elems_code} }})"

    def _expr_dict_literal(self, node: DictLiteral) -> str:
        # py_dict(std::vector<std::pair<PyValue, PyValue>>{ {k1,v1}, {k2,v2}, ... })
        if not node.pairs:
            return "py_dict(std::vector<std::pair<PyValue, PyValue>>{})"

        items_code_parts = []
        for pair in node.pairs:
            key_code = self._expr(pair.key)
            value_code = self._expr(pair.value)
            items_code_parts.append(f"std::make_pair({key_code}, {value_code})")

        items_code = ", ".join(items_code_parts)
        return "py_dict(std::vector<std::pair<PyValue, PyValue>>{ " + items_code + " })"

    def _expr_index(self, node: Index) -> str:
        # value[index] -> py_getitem(value, index)
        container_code = self._expr(node.value)
        index_code = self._expr(node.index)
        return f"py_getitem({container_code}, {index_code})"
