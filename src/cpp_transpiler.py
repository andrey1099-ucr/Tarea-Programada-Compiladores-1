# src/cpp_transpiler.py

from __future__ import annotations

from typing import List, Set

from src.ast_nodes import (
    Program,
    FunctionDef,
    Name,
    Constant,
    Assign,
    Return,
    Pass,
    Break,
    Continue,
    If,
    While,
    For,
    Call,
    BinaryOp,
    UnaryOp,
    ListLiteral,
    TupleLiteral,
    DictLiteral,
    KeyValue,
    Index,
    Node,
)


class CppTranspiler:
    def __init__(self) -> None:
        self.lines: List[str] = []
        self.indent_level: int = 0

    # ---------- public API ----------

    def transpile(self, program: Program) -> str:
        """Generate full C++ code from the root Program node."""
        self.lines = []
        self.indent_level = 0

        self._emit_preamble()
        self._emit_program(program)

        return "\n".join(self.lines)

    # ---------- low-level emit helpers ----------

    def _emit(self, line: str = "") -> None:
        indent = "    " * self.indent_level
        self.lines.append(indent + line)

    def _indent(self) -> None:
        self.indent_level += 1

    def _dedent(self) -> None:
        if self.indent_level > 0:
            self.indent_level -= 1

    # ---------- preamble and overall layout ----------

    def _emit_preamble(self) -> None:
        self._emit("// Generated by simple Fangless Python transpiler")
        self._emit('#include "../c++/runtime.hpp"')
        self._emit("")
        self._emit("// Compile with something like:")
        self._emit("//   g++ -std=c++17 output.cpp -o program")
        self._emit("")

    def _emit_program(self, program: Program) -> None:
        functions: List[FunctionDef] = []
        globals: List[Node] = []

        for node in program.body:
            if isinstance(node, FunctionDef):
                functions.append(node)
            else:
                globals.append(node)

        # Emit function definitions first
        for func in functions:
            self._emit_function(func)
            self._emit("")

        # Then emit main() with all global-level statements
        self._emit_main(globals)

    # ---------- assignment collection for Python-like scopes ----------

    def _collect_assigned_names_in_stmts(self, stmts: List[Node]) -> Set[str]:
        """
        Traverse a list of statements and return the set of variable names
        that appear as assignment targets (Name nodes).

        This includes assignments inside if / elif / else / while / for blocks.
        """
        names: Set[str] = set()

        for stmt in stmts:
            if isinstance(stmt, Assign):
                if isinstance(stmt.target, Name):
                    names.add(stmt.target.id)

            elif isinstance(stmt, If):
                # if body
                names |= self._collect_assigned_names_in_stmts(stmt.body)
                # elif clauses
                for elif_clause in stmt.elifs:
                    names |= self._collect_assigned_names_in_stmts(elif_clause.body)
                # else body
                if stmt.orelse:
                    names |= self._collect_assigned_names_in_stmts(stmt.orelse)

            elif isinstance(stmt, While):
                names |= self._collect_assigned_names_in_stmts(stmt.body)

            elif isinstance(stmt, For):
                # loop variable
                if isinstance(stmt.target, Name):
                    names.add(stmt.target.id)
                names |= self._collect_assigned_names_in_stmts(stmt.body)

        return names

    # ---------- functions and main ----------

    def _emit_function(self, func: FunctionDef) -> None:
        # All parameters are represented as PyValue
        param_names = [p.name.id for p in func.params]
        params_code = ", ".join(f"PyValue {name}" for name in param_names)

        self._emit(f"PyValue {func.name.id}({params_code}) {{")
        self._indent()

        # 1) Collect all assigned variable names inside the function body
        assigned = self._collect_assigned_names_in_stmts(func.body)

        # 2) Local variables are assigned names minus parameters
        local_vars = assigned.difference(param_names)

        # 3) Declare all local variables at the beginning (Python-like function scope)
        for var in sorted(local_vars):
            self._emit(f"PyValue {var};")

        # 4) Set of all declared names inside this function (params + locals)
        declared: Set[str] = set(param_names) | local_vars

        # 5) Emit the function body
        for stmt in func.body:
            self._emit_stmt(stmt, declared)

        # If control reaches here, return None
        self._emit("return PyValue();")

        self._dedent()
        self._emit("}")

    def _emit_main(self, stmts: List[Node]) -> None:
        self._emit("int main() {")
        self._indent()

        # Same logic as function scope: collect all assigned variables
        assigned = self._collect_assigned_names_in_stmts(stmts)
        local_vars = assigned  # main has no parameters

        for var in sorted(local_vars):
            self._emit(f"PyValue {var};")

        declared: Set[str] = set(local_vars)

        for stmt in stmts:
            self._emit_stmt(stmt, declared)

        self._emit("return 0;")
        self._dedent()
        self._emit("}")

    # ---------- statements ----------

    def _emit_stmt(self, node: Node, declared: Set[str]) -> None:
        if isinstance(node, Assign):
            self._emit_assign(node, declared)
        elif isinstance(node, Return):
            self._emit_return(node)
        elif isinstance(node, If):
            self._emit_if(node, declared)
        elif isinstance(node, While):
            self._emit_while(node, declared)
        elif isinstance(node, For):
            self._emit_for(node, declared)
        elif isinstance(node, Call):
            self._emit_call_stmt(node, declared)
        elif isinstance(node, Pass):
            self._emit("; // pass")
        elif isinstance(node, Break):
            self._emit("break;")
        elif isinstance(node, Continue):
            self._emit("continue;")
        else:
            raise NotImplementedError(f"Unsupported statement: {type(node).__name__}")

    def _emit_assign(self, stmt: Assign, declared: Set[str]) -> None:
        # Only support "name = expr" for now
        if not isinstance(stmt.target, Name):
            raise NotImplementedError(
                "Only simple variable assignment is supported for now"
            )

        var_name = stmt.target.id
        expr_code = self._expr(stmt.value)

        if var_name in declared:
            self._emit(f"{var_name} = {expr_code};")
        else:
            # Fallback in case something was not collected; declare it here
            declared.add(var_name)
            self._emit(f"PyValue {var_name} = {expr_code};")

    def _emit_return(self, stmt: Return) -> None:
        if stmt.value is None:
            self._emit("return PyValue();")
        else:
            expr_code = self._expr(stmt.value)
            self._emit(f"return {expr_code};")

    def _emit_if(self, stmt: If, declared: Set[str]) -> None:
        # if part
        cond_code = self._expr(stmt.condition)
        self._emit(f"if ({cond_code}.is_truthy()) {{")
        self._indent()
        for s in stmt.body:
            self._emit_stmt(s, declared)
        self._dedent()
        self._emit("}")

        # elif parts
        for elif_clause in stmt.elifs:
            cond_code = self._expr(elif_clause.condition)
            self._emit(f"else if ({cond_code}.is_truthy()) {{")
            self._indent()
            for s in elif_clause.body:
                self._emit_stmt(s, declared)
            self._dedent()
            self._emit("}")

        # else part
        if stmt.orelse:
            self._emit("else {")
            self._indent()
            for s in stmt.orelse:
                self._emit_stmt(s, declared)
            self._dedent()
            self._emit("}")

    def _emit_while(self, stmt: While, declared: Set[str]) -> None:
        cond_code = self._expr(stmt.condition)
        self._emit(f"while ({cond_code}.is_truthy()) {{")
        self._indent()
        for s in stmt.body:
            self._emit_stmt(s, declared)
        self._dedent()
        self._emit("}")

    def _emit_for(self, stmt: For, declared: Set[str]) -> None:
        # Support two cases:
        #   for i in range(...):
        #   for x in some list or tuple:
        iterable = stmt.iterable

        if (
            isinstance(iterable, Call)
            and isinstance(iterable.func, Name)
            and iterable.func.id == "range"
        ):
            self._emit_for_range(stmt, iterable, declared)
        else:
            self._emit_for_iterable(stmt, declared)

    def _emit_for_range(self, stmt: For, range_call: Call, declared: Set[str]) -> None:
        target_name = stmt.target.id
        args = range_call.args
        n = len(args)

        # Translate Python range into start, stop, step.
        if n == 1:
            start_code = "PyValue(0)"
            stop_code = self._expr(args[0])
            step_code = "PyValue(1)"
        elif n == 2:
            start_code = self._expr(args[0])
            stop_code = self._expr(args[1])
            step_code = "PyValue(1)"
        elif n == 3:
            start_code = self._expr(args[0])
            stop_code = self._expr(args[1])
            step_code = self._expr(args[2])
        else:
            raise NotImplementedError(
                "range() with more than 3 arguments is not supported"
            )

        self._emit("{")
        self._indent()

        # Evaluate start/stop/step once.
        self._emit(f"PyValue __range_start = {start_code};")
        self._emit(f"PyValue __range_stop = {stop_code};")
        self._emit(f"PyValue __range_step = {step_code};")

        # Make sure the loop variable is declared.
        if target_name not in declared:
            self._emit(f"PyValue {target_name};")
            declared.add(target_name)

        self._emit(
            "for (long long __i = __range_start.int_value; "
            "__i < __range_stop.int_value; "
            "__i += __range_step.int_value) {"
        )
        self._indent()

        # Assign value to the loop variable each iteration.
        self._emit(f"{target_name} = PyValue(__i);")

        for s in stmt.body:
            self._emit_stmt(s, declared)

        self._dedent()
        self._emit("}")

        self._dedent()
        self._emit("}")

    def _emit_for_iterable(self, stmt: For, declared: Set[str]) -> None:
        target_name = stmt.target.id
        iter_code = self._expr(stmt.iterable)

        self._emit("{")
        self._indent()

        # Evaluate iterable expression once.
        self._emit(f"PyValue __iter = {iter_code};")

        # Simple runtime check: only lists and tuples are supported here.
        self._emit(
            "if (__iter.type != PyValue::LIST && __iter.type != PyValue::TUPLE) { "
            'throw std::runtime_error("TypeError: can only iterate over list or tuple in for-loop"); '
            "}"
        )

        if target_name not in declared:
            self._emit(f"PyValue {target_name};")
            declared.add(target_name)

        # Choose underlying container depending on type.
        self._emit("if (__iter.type == PyValue::LIST) {")
        self._indent()
        self._emit(
            "for (std::size_t __idx = 0; __idx < __iter.list_value.size(); ++__idx) {"
        )
        self._indent()
        self._emit(f"{target_name} = __iter.list_value[__idx];")
        for s in stmt.body:
            self._emit_stmt(s, declared)
        self._dedent()
        self._emit("}")
        self._dedent()
        self._emit("} else {")
        self._indent()
        self._emit(
            "for (std::size_t __idx = 0; __idx < __iter.tuple_value.size(); ++__idx) {"
        )
        self._indent()
        self._emit(f"{target_name} = __iter.tuple_value[__idx];")
        for s in stmt.body:
            self._emit_stmt(s, declared)
        self._dedent()
        self._emit("}")
        self._dedent()
        self._emit("}")

        self._dedent()
        self._emit("}")

    def _emit_call_stmt(self, call: Call, declared: Set[str]) -> None:
        # Special-case builtin print(...)
        if isinstance(call.func, Name) and call.func.id == "print":
            if len(call.args) == 1:
                arg_code = self._expr(call.args[0])
                self._emit(f"py_print({arg_code});")
            else:
                args_code = ", ".join(self._expr(a) for a in call.args)
                self._emit(f"py_print_many(std::vector<PyValue>{{ {args_code} }});")
        else:
            expr_code = self._expr(call)
            self._emit(f"{expr_code};")

    # ---------- expressions ----------

    def _expr(self, node: Node) -> str:
        if isinstance(node, Name):
            return node.id
        if isinstance(node, Constant):
            return self._expr_constant(node)
        if isinstance(node, BinaryOp):
            return self._expr_binary(node)
        if isinstance(node, UnaryOp):
            return self._expr_unary(node)
        if isinstance(node, Call):
            return self._expr_call(node)
        if isinstance(node, ListLiteral):
            return self._expr_list_literal(node)
        if isinstance(node, TupleLiteral):
            return self._expr_tuple_literal(node)
        if isinstance(node, DictLiteral):
            return self._expr_dict_literal(node)
        if isinstance(node, Index):
            return self._expr_index(node)

        raise NotImplementedError(f"Unsupported expression: {type(node).__name__}")

    def _expr_constant(self, node: Constant) -> str:
        val = node.value

        # In Python, bool is a subclass of int, so check it first
        if isinstance(val, bool):
            return "PyValue(true)" if val else "PyValue(false)"
        if isinstance(val, int):
            return f"PyValue({val})"
        if isinstance(val, float):
            return f"PyValue({val})"
        if isinstance(val, str):
            # In our AST, string literals usually already include quotes
            return f"PyValue({val})"

        # Fallback: None / unsupported
        return "PyValue()"

    def _expr_binary(self, node: BinaryOp) -> str:
        left = self._expr(node.left)
        right = self._expr(node.right)
        op = node.op

        # Arithmetic
        if op == "ADD":
            return f"py_add({left}, {right})"
        if op == "MINUS":
            return f"py_sub({left}, {right})"
        if op == "TIMES":
            return f"py_mul({left}, {right})"
        if op == "DIVIDE":
            return f"py_div({left}, {right})"
        if op == "MODULE":
            return f"py_mod({left}, {right})"

        # Comparisons
        if op == "EQUAL_EQUAL":
            return f"py_eq({left}, {right})"
        if op == "NOT_EQUAL":
            return f"py_ne({left}, {right})"
        if op == "LESS":
            return f"py_lt({left}, {right})"
        if op == "LESS_EQUAL":
            return f"py_le({left}, {right})"
        if op == "GREATER":
            return f"py_gt({left}, {right})"
        if op == "GREATER_EQUAL":
            return f"py_ge({left}, {right})"

        # Logical
        if op == "AND":
            return f"py_and({left}, {right})"
        if op == "OR":
            return f"py_or({left}, {right})"

        raise NotImplementedError(f"Unsupported binary op: {op}")

    def _expr_unary(self, node: UnaryOp) -> str:
        if node.op == "NOT":
            operand = self._expr(node.operand)
            return f"py_not({operand})"
        raise NotImplementedError(f"Unsupported unary op: {node.op}")

    def _expr_call(self, node: Call) -> str:
        # Only support calls to simple names: foo(...)
        if isinstance(node.func, Name):
            func_name = node.func.id

            # Builtin: str(x) -> py_str(x)
            if func_name == "str":
                if len(node.args) != 1:
                    raise NotImplementedError(
                        "str() with != 1 argument is not supported"
                    )
                arg_code = self._expr(node.args[0])
                return f"py_str({arg_code})"

            # Builtin: len(x) -> py_len(x)
            if func_name == "len":
                if len(node.args) != 1:
                    raise NotImplementedError(
                        "len() with != 1 argument is not supported"
                    )
                arg_code = self._expr(node.args[0])
                return f"py_len({arg_code})"

            # Regular function call: foo(a, b, ...)
            args_code = ", ".join(self._expr(a) for a in node.args)
            return f"{func_name}({args_code})"

        raise NotImplementedError("Only simple function calls are supported for now")

    def _expr_list_literal(self, node: ListLiteral) -> str:
        # py_list(std::vector<PyValue>{ elem1, elem2, ... })
        if not node.elements:
            return "py_list(std::vector<PyValue>{})"

        elems_code = ", ".join(self._expr(e) for e in node.elements)
        return f"py_list(std::vector<PyValue>{{ {elems_code} }})"

    def _expr_tuple_literal(self, node: TupleLiteral) -> str:
        # py_tuple(std::vector<PyValue>{ elem1, elem2, ... })
        if not node.elements:
            return "py_tuple(std::vector<PyValue>{})"

        elems_code = ", ".join(self._expr(e) for e in node.elements)
        return f"py_tuple(std::vector<PyValue>{{ {elems_code} }})"

    def _expr_dict_literal(self, node: DictLiteral) -> str:
        # py_dict(std::vector<std::pair<PyValue, PyValue>>{ {k1,v1}, {k2,v2}, ... })
        if not node.pairs:
            return "py_dict(std::vector<std::pair<PyValue, PyValue>>{})"

        items_code_parts = []
        for pair in node.pairs:
            key_code = self._expr(pair.key)
            value_code = self._expr(pair.value)
            items_code_parts.append(f"std::make_pair({key_code}, {value_code})")

        items_code = ", ".join(items_code_parts)
        return "py_dict(std::vector<std::pair<PyValue, PyValue>>{ " + items_code + " })"

    def _expr_index(self, node: Index) -> str:
        # value[index] -> py_getitem(value, index)
        container_code = self._expr(node.value)
        index_code = self._expr(node.index)
        return f"py_getitem({container_code}, {index_code})"
